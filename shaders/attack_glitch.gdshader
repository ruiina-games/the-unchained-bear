shader_type canvas_item;

// ----------------------------------------------------
// ПАРАМЕТРИ "ГЛІТЧ" ЕФЕКТУ
// ----------------------------------------------------

// Сила "трясіння"
uniform float shake_power = 0.03;
// Ймовірність "ривка"
uniform float shake_rate : hint_range(0.0, 1.0) = 0.2;
// Швидкість "ривків" (як швидко вони виникають з плином часу)
uniform float shake_speed = 5.0;
// Розмір блоків, за якими обчислюється зміщення (ефект "блоковості")
uniform float shake_block_size = 30.5;
// Ступінь "кольорового зсуву" (R і B канали)
uniform float shake_color_rate : hint_range(0.0, 1.0) = 0.01;

// ----------------------------------------------------
// ПАРАМЕТР ПРОЯВЛЕННЯ
// ----------------------------------------------------

// Наскільки зверху донизу текстура відкрита (0 – все сховано, 1 – все видно)
uniform float reveal : hint_range(0.0, 1.0) = 0.0;

// ----------------------------------------------------
// ПСЕВДОВИПАДКОВА ФУНКЦІЯ
// ----------------------------------------------------
float random(float seed) {
    return fract(543.2543 * sin(dot(vec2(seed, seed), vec2(3525.46, -54.3415))));
}

// ----------------------------------------------------
// ОСНОВНИЙ ФРАГМЕНТ-ШЕЙДЕР
// ----------------------------------------------------
void fragment() {
    //-------------------------------------------------
    // 1) Визначаємо, чи буде "ривок" (enable_shift)
    //-------------------------------------------------
    float enable_shift = float(
        random(trunc(TIME * shake_speed)) < shake_rate
    );

    //-------------------------------------------------
    // 2) Обчислюємо зміщення UV для глітч-ефекту
    //-------------------------------------------------
    vec2 fixed_uv = UV;

    fixed_uv.x += (
        random(
            (trunc(UV.y * shake_block_size) / shake_block_size) + TIME
        ) - 0.5
    ) * shake_power * enable_shift;

    //-------------------------------------------------
    // 3) Зчитуємо текстуру (у випадку білої текстури –
    //    це просто "1.0" по всіх каналах, але альфа
    //    теж може бути важлива)
    //-------------------------------------------------
    vec4 tex_color = texture(TEXTURE, fixed_uv);

    //-------------------------------------------------
    // 4) Кольоровий зсув (R- і B-канали)
    //-------------------------------------------------
    float shifted_r = texture(TEXTURE, fixed_uv + vec2(shake_color_rate, 0.0)).r;
    float shifted_b = texture(TEXTURE, fixed_uv + vec2(-shake_color_rate, 0.0)).b;

    tex_color.r = mix(tex_color.r, shifted_r, enable_shift);
    tex_color.b = mix(tex_color.b, shifted_b, enable_shift);

    //-------------------------------------------------
    // 5) Помножимо на вхідний колір (COLOR) аби
    //    зберігати модульований колір частинки/спрайта
    //-------------------------------------------------
    tex_color *= COLOR;

     //-------------------------------------------------
    // 6) Ефект "проявлення" з гори до низу:
    //    Якщо UV.y перевищує reveal – робимо альфу 0.
    //-------------------------------------------------
    //    step(a, b) повертає 1.0, якщо a >= b, інакше 0.0.
    //    Але нам треба "1.0", коли UV.y <= reveal:
    //    тому робимо mask = step(UV.y, reveal) – це буде 1.0,
    //    якщо UV.y <= reveal, інакше 0.0.
    //-------------------------------------------------
    float mask = step(UV.y, reveal);
    tex_color.a *= mask; // "відрізаємо" нижню частину

    //-------------------------------------------------
    // 7) Фінальний колір
    //-------------------------------------------------
    COLOR = tex_color;
}